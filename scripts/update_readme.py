import os
import re
import subprocess
from datetime import datetime

ROOT = "."
README = "README.md"
EXTENSIONS = {".py", ".cpp", ".c", ".cc", ".java", ".js", ".ts", ".cs", ".hpp", ".h"}


def slugify(title: str) -> str:
    """Create a leetcode-style slug from a title string.

    Examples:
    - '2125. Number of Laser Beams in a Bank' -> 'number-of-laser-beams-in-a-bank'
    - 'Group_Anagrams' -> 'group-anagrams'
    """
    s = title.lower()
    # remove leading numbering like '2125.'
    s = re.sub(r"^\s*\d+\.\s*", "", s)
    # remove the word 'leetcode' (optional)
    s = re.sub(r"\bleetcode\b", "", s, flags=re.I)
    # replace non-alnum with hyphens
    s = re.sub(r"[^a-z0-9]+", "-", s)
    s = re.sub(r"-+", "-", s).strip("-")
    return s


def extract_title(path: str) -> str:
    """Try to extract a human-friendly title from the file's top comments.

    Fallbacks to filename (without extension) when no title is found.
    """
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            for _ in range(6):
                line = f.readline()
                if not line:
                    break
                # look for patterns like '2125. Title...' or '# 2125. Title' or '// Title'
                m = re.search(r"\d+\.\s*(.+)", line)
                if m:
                    return m.group(1).strip()
                # comment lines starting with // or # or /*
                m2 = re.search(r"^[\s#/*]*([A-Za-z0-9][^\n\r]+)$", line)
                if m2:
                    txt = m2.group(1).strip()
                    # avoid returning a short one-letter token
                    if len(txt) > 2:
                        # strip leading digits + dot if present
                        txt = re.sub(r"^\d+\.\s*", "", txt)
                        return txt
    except Exception:
        pass

    return os.path.splitext(os.path.basename(path))[0]


def git_date_for_file(path: str) -> str:
    """Return last commit date for a file in YYYY-MM-DD format.

    Falls back to file modification time if git is not available or file not committed.
    """
    try:
        res = subprocess.run(["git", "log", "-1", "--format=%ad", "--date=short", "--", path],
                             capture_output=True, text=True, check=True)
        date = res.stdout.strip()
        if date:
            return date
    except Exception:
        pass

    ts = os.path.getmtime(path)
    return datetime.utcfromtimestamp(ts).strftime("%Y-%m-%d")


def should_include(path: str) -> bool:
    name = os.path.basename(path)
    # skip hidden and repo directories
    if name.startswith("."):
        return False
    if os.path.isdir(path):
        return False
    if name.upper() == "README.MD":
        return False
    ext = os.path.splitext(name)[1].lower()
    return ext in EXTENSIONS


def main():
    entries = []

    for item in sorted(os.listdir(ROOT)):
        path = os.path.join(ROOT, item)
        if not should_include(path):
            continue

        title = extract_title(path)
        slug = slugify(title)
        link = f"https://leetcode.com/problems/{slug}/" if slug else ""
        date = git_date_for_file(path)
        relpath = f"./{item}"
        entries.append({"date": date, "title": title, "link": link, "path": relpath})

    # sort by date descending
    entries.sort(key=lambda e: e["date"], reverse=True)

    table = "| Date | Problem Name | Leetcode Link | Solution |\n"
    table += "|------|---------------|----------------|-----------|\n"
    for e in entries:
        display_title = e["title"].replace("_", " ")
        link_md = f"[ðŸ”— Link]({e['link']})" if e["link"] else ""
        table += f"| {e['date']} | {display_title} | {link_md} | [View]({e['path']}) |\n"

    content = f"""# ðŸ§© Leetcode Problem of the Day Tracker

{table}

> Auto-generated by a GitHub Action (or local script) ðŸš€
"""

    with open(README, "w", encoding="utf-8") as f:
        f.write(content)

    print("âœ… README.md updated successfully.")


if __name__ == "__main__":
    main()
